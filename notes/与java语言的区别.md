### 基本语法
* 函数定义：返回值申明 , 空返回值 , 参数申明为变量名在前 , 类型在后
* 变量定义
    * 局部只读变量 val , 只能赋值一次
    * 可重新赋值变量 var
* 注解：内联标记使用 markdown , 支持链接
* 字符串支持模版
* 空值安全机制
    * kotlin中类型系统区分一个引用是否容纳 null , 比如 String 类型的常规变量不能容纳 null , 会直接编译错误
    * 如果允许变量为 null , 比如 String , 则声明为 String？
    * 安全调用，如果 val b: String? = null , 则 println（b?.length） 当 b 为 null 时返回 null 不为 null 时返回 b.length.
* while 和 for 循环大同小异 , for 等同于 foreach
* when 代替了 switch 操作符
* 新增 in 处理区间函数

### 习惯用法
* 具有少数主构造函数参数的类写成一行
* 鼓励函数定义默认参数
* list 过滤使用 filter
* 只读 list 时使用 val
* 善用 ？ 处理 null 值的逻辑场景
* 单表达式函数直接使用 = 返回值 不用 return , 或者和其他表达式比如 when 一起使用等


### 编程规范
* 代码结构 , 文件命名/命名 , 类/方法命名与 java 一致
* 横向空白要遵循的比较多 , 需要严格遵守
    * 绝不在 (、 [ 之后或者 ]、 ) 之前留空格
    * 绝不在. 或者 ?. 左右留空格 : foo.bar().filter { it > 2 }.joinToString(), foo?.bar()
    * 在 // 之后留一个空格 : // 这是一条注释
    * 不要在用于指定类型参数的尖括号前后留空格 : ：class Map<K, V> { …… }
    * 不要在 :: 前后留空格 : Foo::class、 String::length
    * 不要在用于标记可空类型的 ? 前留空格 : String?
* 冒号场景，在分割声明与类型时冒号之前不要留空格，以下场景需要在冒号前留一个空格
    * 当它用于分隔类型与超类型时
    * 当委托给一个超类的构造函数或者同一类的另一个构造函数时
    * 在 object 关键字之后
    ```
    abstract class Foo<out T : Any> : IFoo {
        abstract fun foo(a: Int): T
    }

    class FooImpl : Foo() {
        constructor(x: String) : this(x) { …… }

        val x = object : IFoo { …… }
    }

    ```
* 函数的表达式函数体与函数声明不适合放在同一行
* 链式调用使用换行, . 和 ?. 在下一行并单倍缩进

### 基本类型

内置的基本类型与 java 基本一致

| Type | Kotlin Bit width | Java Bit width |
| :------| :------: | :------: |
|Double| 64|64|
|Float|32|32|
|Long|64|64|
|Int|32|32|
|Short|16|16|
|Byte|8|8|

### 控制流
* if 是一个表达式, 会返回一个值
* when 也可以返回一个值

### 类与对象
* 类与继承
    * 区分主构造函数和次构造函数, 存在 init 初始化块
    * 初始化一个类的实例不需要 new 关键字
    * 继承中需要初始化基类的主构造函数
    * 继承中覆盖方法需要基类函数标注 open, 可使用 final 禁止覆盖
    * 继承中覆盖属性和覆盖方法相似
    * 不存在静态方法, 使用伴生对象处理
* 属性
    * 存在 initalizer getter 和 setter
    * 编译器常量使用 const 标志
    * 使用 lateinit 标示延迟初始化属性
* 接口
    * 接口内可以自己实现方法, 实现类可通过 super<T> 选择性调用父接口方法
* 可见性修饰符
    * 新增 internal, 默认是 public
    * public 同 java 对所有类都可见
    * private 同个文件内可见 如果是类内则类内可见, java 为同个类内可见
    * internal 同个模块内可见
    * protected 如果是类内则类内和子类可见, java 同个包内的类和所有子类
* 扩展 , 支持扩展属性和扩展方法
* 数据类用于处理类似 java bean 的数据结构
* 密封类用于处理类似抽象类
* 泛型
    * 支持 "声明处型变", 使用 out 修饰符申明类型, 生产者同 java ？extends Object
    * 支持类型参数逆变, 使用 in 修饰符申明类型 , 消费者同 java  ? super object
* 内部类与嵌套类同 java
* 枚举类支持匿名类, 同 java 支持实现接口
* 支持对象表达式, 可以通过匿名对象引用直接操作对象属性 , 在使用到的地方立即初始化
* 对象声明
    * 通过 object 声明对象, 用于单例模式下的单一对象, 被第一次访问时延迟初始化
    * 通过 companion 声明伴生对象 , 支持实现接口, 在类被加载解析时变初始化了
* 内联类, 解决优化部分围绕某个类型创建的包装器
    * 通过 inline 声明内联类, 必须包含唯一的一个属性在主构造器中初始化, 支持实现接口
    * 不能有 init 代码块, 不能有 inner 类, 不能包含幕后字段
* 委托, 可替代继承的一种方法 , 和适配器模式很像
* 委托属性, 可自定义管理属性委托
    * 标准委托, 为 kotlin 提供的一种延迟初始化属性的方法, 默认支持同步锁
    * 可观测属性 Observable 支持处理程序对属性进行逻辑执行
    * 把属性存储在映射中, 比如 map

### 函数与 Lambda
    * 参数类型使用 Pascal 表示法定义, name:type
    * 函数可以有默认值, 当省略对应参数的值时使用默认值, 减少重载函数的数量
    * 覆盖带有默认参数值的方法, 必须在签名中省略默认值(不能重定义默认值)
    * 支持命名参数语法, java函数不支持, 在 java字节码中并不总是保留函数参数的名字
    * Unit 可表示不返回任何有用的值, 可以不需要显式返回
    * 重点掌握函数与 java 的区别

### 平台相关声明
    * 支持预期声明, 编译器会确保每个预期声明在所有平台模块中都具有实际声明, 如果缺少实际声明则会报错

### 其他需要掌握
    * 解构
    * 集合 list map 等
    * 区间 底层使用区间+数列
    * 类型检查转化使用 is 和 as



